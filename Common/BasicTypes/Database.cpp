#include "Database.h"

ResultRow::ResultRow(ResultSet* rs) {
	if (rs != nullptr) {
		results = SharedArrayPtr<String>(new String[rs->getColumnAmount()], rs->getColumnAmount());
		auto currentResult = rs->getNext();
		for (unsigned int i = 0; i < this->results.getSize(); i++) {
			results[i] = String(currentResult[i]);
		}
	}
}

unsigned long long Statement::getAutoGeneratedKey() const {
	return (mysql_insert_id(this->getDb()->getSqlHandle()) != 0 ? mysql_insert_id(this->getDb()->getSqlHandle()) : 0x00);
}

std::shared_ptr<ResultSet> Statement::executeWithResult() {
	if (this->execute()) {
		std::shared_ptr<ResultSet> result(new ResultSet(mysql_store_result(this->getDb()->getSqlHandle())));
		return result;
	}
	return std::shared_ptr<ResultSet>();
}


bool Statement::execute() {
	if (mysql_real_query(this->getDb()->getSqlHandle(), this->toString().toConstChar(), this->toString().length()) != 0) {
		if (this->getDb()->reconnect()) {
			return this->execute();
		}
		return false;
	}
	if (this->callback) {
		this->callback();
	}
	return true;
}


Transaction::~Transaction() {
	if (this->getDB() != nullptr && !this->getDB()->getAutoCommit()) {
		(this->statementsSuccessfullyExecuted ? this->getDB()->commit() : this->getDB()->rollback());
	}
}

bool Transaction::execute() {
	if (this->statements.size() == 0) {
		return true;
	}
	std::for_each(this->statements.begin(), this->statements.end(), [&](Statement& stm) {
		if (stm.getDb() == nullptr) {
			stm.setDB(this->getDB());
		}
		this->statementsSuccessfullyExecuted &= stm.execute();
	});
	return this->statementsSuccessfullyExecuted;
}