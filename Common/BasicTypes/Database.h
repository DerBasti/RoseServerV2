#include <mysql.h>
#include <iostream>
#include "StringWrapper.h"
#include "SharedArrayPointer.h"
#include <memory>

#ifdef _MSC_VER
#pragma once
#pragma comment(lib, "libmysql")
#endif

#ifndef __DEFAULT_DATABASE__
#define __DEFAULT_DATABASE__

#define __DATABASE_HOST__ "localhost"
#define __DATABASE_PORT__ 3306
#define __DATABASE_USERNAME__ "root"
#define __DATABASE_PASSWORD__ "bla123"
#define __DATABASE_DBNAME__ "roseonline"

#endif

class ResultRow {
private:
	SharedArrayPtr<String> results;
	friend class ResultSet;
	ResultRow(ResultSet* rs);
public:
	ResultRow() {
	}
	ResultRow& operator=(const ResultRow& r) {
		this->results = r.results;
		return (*this);
	}
	virtual ~ResultRow() {
	}
	__inline String& operator[](const unsigned long num) {
		return this->results.at(num);
	}
	__inline String get(unsigned int colId) {
		return this->results[colId];
	}
};

class ResultSet {
private:
	MYSQL_RES *result;
	SharedArrayPtr<ResultRow> resultSet;
	friend ResultRow;
	friend class Statement;

	ResultSet(MYSQL_RES *res) {
		this->result = res;

		unsigned long amount = static_cast<unsigned long>(this->getResultAmount());
		resultSet = SharedArrayPtr<ResultRow>(amount == 0 ? nullptr : new ResultRow[amount], amount);
		for (unsigned int i = 0; i < amount; i++) {
			resultSet[i] = ResultRow(this);
		}
	}

	__inline MYSQL_ROW getNext() const {
		return (!this->result ? nullptr : mysql_fetch_row(this->result));
	}
public:
	ResultSet() : ResultSet(nullptr) {
	}
	virtual ~ResultSet() {
		if (this->result != nullptr) {
			mysql_free_result(this->result);
		}
		this->result = nullptr;
	}
	__inline bool hasResult() const {
		return this->result != nullptr;
	}

	__inline unsigned long long getResultAmount() const {
		return this->result == nullptr ? 0x00 : this->result->row_count;
	}

	__inline unsigned long getColumnAmount() const {
		return this->result == nullptr ? 0x00 : this->result->field_count;
	}

	__inline ResultRow getFirst() const {
		return this->resultSet.at(0);
	}
	__inline ResultRow getRow(const unsigned long row) const {
		return this->resultSet.at(row);
	}
	__inline SharedArrayPtr<ResultRow> getResultRows() {
		return this->resultSet;
	}
};


class Statement {
private:
	String query;
	class DataBase *dbHandle;
	std::function<void()> callback;
public:

	Statement() : Statement(nullptr, nullptr) {}
	explicit Statement(const char *query) : Statement(String(query)) {}
	explicit Statement(const String& query) : Statement(nullptr, query) {}

	Statement(DataBase *db) : Statement(db, nullptr) {}
	Statement(DataBase *db, const char* query) : Statement(db, String(query)) {}
	Statement(DataBase *db, const String& query) {
		this->dbHandle = db;
		this->query = query;
		this->callback = []() {};
	}
	Statement& operator=(const char *qry) {
		return this->operator=(String(qry));
	}
	Statement& operator=(const String& qry) {
		this->query = qry;
		return (*this);
	}
	
	__inline operator const char*() const {
		return this->query.toConstChar();
	}
	__inline void setString(const char* val) {
		this->setString(String(val));
	}
	__inline void setBool(const bool value){
		this->query.replaceOnce('?', String::fromBool(value));
	}
	__inline void setString(const String& val) {
		this->query.replaceOnce('?', String("'") + val + String("'"));
	}
	__inline void setUInt(const unsigned int num) {
		this->query.replaceOnce('?', String::fromInt(num));
	}
	__inline void setInt(const int num) {
		char buf[0x50] = { 0x00 };
		sprintf_s(buf, "%i", num);
		this->query.replaceOnce('?', buf);
	}

	__inline DataBase* getDb() const {
		return this->dbHandle;
	}
	__inline void setDB(DataBase* db) {
		this->dbHandle = db;
	}

	unsigned long long getAutoGeneratedKey() const;

	__inline void setCallbackFunction(std::function<void()> func) {
		this->callback = func;
	}

	std::shared_ptr<ResultSet> executeWithResult();
	bool execute();

	__inline String toString() const {
		return String(query);
	}
};

class Transaction {
private:
	std::vector<Statement> statements;
	class DataBase* dbHandle;
	bool statementsSuccessfullyExecuted;

	__inline DataBase* getDB() const {
		return this->dbHandle;
	}
public:
	Transaction() : Transaction(nullptr) {}
	Transaction(DataBase* db) {
		this->dbHandle = db;
		this->statementsSuccessfullyExecuted = true;
	}

	virtual ~Transaction();

	__inline void addStatement(const Statement& stm) {
		this->statements.push_back(stm);
	}

	bool execute();
};

class DataBase {
private:
	const char* server;
	const char* userName;
	const char* pw;
	const char* database;
	DWORD port;
	MYSQL* sql;
	String lastQuery;
	bool autoCommitMode;

	bool isConnected;
	const char* errorDesc;

	void showErrorMsg() {
		this->errorDesc = this->lastError();
		std::cout << "[MYSQL ERROR]: " << this->errorDesc << " for query: " << lastQuery << "\n";
	}
public:
	DataBase() : DataBase(nullptr, nullptr, nullptr, nullptr, 0, nullptr) { }
	DataBase(const char* serverAddr, const char* user, const char* password, const char* db, DWORD _port, MYSQL* _mysql) {
		this->server = serverAddr;
		this->userName = user;
		this->sql = _mysql;
		this->pw = password;
		this->database = db;
		this->port = _port;
		this->autoCommitMode = true;

		this->isConnected = false;
		if (this->getSqlHandle()) {
			mysql_init(this->sql);
			this->connect(true);
		}
	}
	~DataBase() {
		this->disconnect();
	}

	bool checkIsConnected() {
		return (this->isConnected = (mysql_ping(this->sql) == 0));
	}

	bool reconnect() {
		if (this->checkIsConnected()) {
			return false;
		}
		if (!mysql_real_connect(this->sql, this->server, this->userName, this->pw, this->database, this->port, nullptr, 0)) {
			return false;
		}
		return true;
	}

	bool connect(bool isInit = false) {
		if (!isInit && this->checkIsConnected())
			return false;
		if (!mysql_real_connect(this->sql, this->server, this->userName, this->pw, this->database, this->port, nullptr, 0)) {
			this->showErrorMsg();
			return false;
		}
		this->isConnected = true;
		return true;
	}

	bool disconnect() {
		if (!this->checkIsConnected()) {
			return false;
		}
		mysql_close(this->sql);
		this->isConnected = false;
		return true;
	}

	__inline bool getAutoCommit() const {
		return this->autoCommitMode;
	}

	__inline void setAutoCommit(const bool commit) {
		this->autoCommitMode = commit;
		mysql_autocommit(this->getSqlHandle(), this->getAutoCommit());
	}

	__inline void commit() const {
		mysql_commit(this->getSqlHandle());
	}

	__inline void rollback() const {
		mysql_rollback(this->getSqlHandle());
	}

	__inline MYSQL* getSqlHandle() const {
		return this->sql;
	}

	__inline const char* lastError() const { return mysql_error(this->sql); }
};